#!/usr/bin/env node
/**
 * Investor Deck Generator - Image-First Approach
 *
 * Generates a professional investor pitch deck by assembling full-slide images
 * generated by Nano Banana Pro. Falls back to programmatic rendering when images
 * are not available.
 *
 * Usage: node generate-deck.js --config deck-config.json --output investor-deck.pptx
 */

const pptxgen = require("pptxgenjs");
const fs = require("fs");
const path = require("path");

// =============================================================================
// Configuration
// =============================================================================

// Parse command line arguments
const args = process.argv.slice(2);
let configPath = "deck-config.json";
let outputPath = "investor-deck.pptx";
let forceImageOnly = false;

for (let i = 0; i < args.length; i++) {
  if (args[i] === "--config" && args[i + 1]) configPath = args[++i];
  if (args[i] === "--output" && args[i + 1]) outputPath = args[++i];
  if (args[i] === "--image-only") forceImageOnly = true;
}

// Load configuration
if (!fs.existsSync(configPath)) {
  console.error(`Config file not found: ${configPath}`);
  console.log("\nCreate a deck-config.json file with your content.");
  process.exit(1);
}

const config = JSON.parse(fs.readFileSync(configPath, "utf8"));
const { company, design, slides } = config;

// Get the directory of the config file for resolving relative paths
const configDir = path.dirname(path.resolve(configPath));

// Check if image-only mode is enabled
const imageOnlyMode = forceImageOnly || config.imageOnlyMode || false;

// =============================================================================
// Presentation Setup
// =============================================================================

const pres = new pptxgen();
pres.layout = "LAYOUT_16x9";
pres.title = `${company.name} - Investor Deck`;
pres.author = company.name;

// Slide dimensions (16:9)
const SLIDE = { w: 10, h: 5.625 };
const MARGIN = 0.5;

// Design constants
const COLORS = {
  primary: design?.primaryColor || "0A0A0A",
  secondary: design?.secondaryColor || "1E3A5F",
  accent: design?.accentColor || "5E5CE6",
  dark: design?.darkColor || "111111",
  light: design?.lightColor || "E8E6E1",
  muted: design?.mutedColor || "64748B",
  white: "FFFFFF",
  black: "000000"
};

const FONTS = {
  title: design?.fontTitle || "Georgia",
  heading: design?.fontHeading || "Arial",
  body: design?.fontBody || "Calibri"
};

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Resolve image path - checks multiple locations
 */
function resolveImagePath(imagePath) {
  if (!imagePath) return null;

  // If absolute path and exists, use it
  if (path.isAbsolute(imagePath) && fs.existsSync(imagePath)) {
    return imagePath;
  }

  // Check relative to config file location
  const relativeToConfig = path.resolve(configDir, imagePath);
  if (fs.existsSync(relativeToConfig)) {
    return relativeToConfig;
  }

  // Check in assets directory relative to config
  const assetsPath = path.resolve(configDir, "assets", path.basename(imagePath));
  if (fs.existsSync(assetsPath)) {
    return assetsPath;
  }

  // Check in output/assets
  const outputAssetsPath = path.resolve(configDir, "output/assets", path.basename(imagePath));
  if (fs.existsSync(outputAssetsPath)) {
    return outputAssetsPath;
  }

  return null;
}

/**
 * Add slide number overlay
 */
function addSlideNumber(slide, num, total) {
  slide.addText(`${num} / ${total}`, {
    x: SLIDE.w - 1, y: SLIDE.h - 0.4, w: 0.8, h: 0.3,
    fontSize: 10, color: COLORS.muted, align: "right",
    fontFace: FONTS.body
  });
}

/**
 * Add logo to slide
 */
function addLogo(slide, logoPath, position = "bottomRight") {
  const resolvedLogo = resolveImagePath(logoPath);
  if (!resolvedLogo) return;

  const positions = {
    bottomRight: { x: SLIDE.w - 1.5, y: SLIDE.h - 0.8 },
    topLeft: { x: MARGIN, y: MARGIN },
    topRight: { x: SLIDE.w - 1.5, y: MARGIN }
  };
  const pos = positions[position] || positions.bottomRight;

  slide.addImage({
    path: resolvedLogo,
    x: pos.x, y: pos.y, w: 1, h: 0.5,
    sizing: { type: "contain", w: 1, h: 0.5 }
  });
}

// =============================================================================
// Image-First Slide Generator
// =============================================================================

/**
 * Generate a slide from a full-bleed image
 * Returns true if successful, false if image not found
 */
function generateImageSlide(slideConfig, slideNum, totalSlides) {
  const imagePath = resolveImagePath(slideConfig.image);

  if (!imagePath) {
    return false; // Signal to use fallback
  }

  const slide = pres.addSlide();

  // Full-bleed image covering entire slide
  slide.addImage({
    path: imagePath,
    x: 0, y: 0, w: SLIDE.w, h: SLIDE.h,
    sizing: { type: "cover", w: SLIDE.w, h: SLIDE.h }
  });

  // Optionally add slide number overlay (subtle, bottom-right)
  if (config.showSlideNumbers !== false) {
    // Add semi-transparent background for number
    slide.addShape(pres.shapes.RECTANGLE, {
      x: SLIDE.w - 0.9, y: SLIDE.h - 0.35, w: 0.8, h: 0.3,
      fill: { color: "000000", transparency: 70 }
    });
    slide.addText(`${slideNum}/${totalSlides}`, {
      x: SLIDE.w - 0.85, y: SLIDE.h - 0.32, w: 0.7, h: 0.25,
      fontSize: 9, color: "FFFFFF", align: "center",
      fontFace: FONTS.body
    });
  }

  return true; // Successfully generated from image
}

// =============================================================================
// Fallback Programmatic Generators
// =============================================================================

const fallbackGenerators = {
  title: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.primary };

    slide.addText(company.name.toUpperCase(), {
      x: MARGIN, y: 1.8, w: SLIDE.w - MARGIN * 2, h: 1,
      fontSize: 48, fontFace: FONTS.title, color: COLORS.white,
      bold: true, align: "center"
    });

    slide.addText(company.tagline || slideConfig.tagline || "", {
      x: MARGIN, y: 2.8, w: SLIDE.w - MARGIN * 2, h: 0.6,
      fontSize: 24, fontFace: FONTS.body, color: COLORS.light,
      align: "center"
    });

    if (slideConfig.subtitle) {
      slide.addText(slideConfig.subtitle, {
        x: MARGIN, y: 3.5, w: SLIDE.w - MARGIN * 2, h: 0.4,
        fontSize: 16, fontFace: FONTS.body, color: COLORS.secondary,
        align: "center"
      });
    }

    slide.addShape(pres.shapes.RECTANGLE, {
      x: 3.5, y: 4.5, w: 3, h: 0.05,
      fill: { color: COLORS.accent }
    });

    addLogo(slide, company.logo, "bottomRight");
  },

  purpose: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.light };

    slide.addShape(pres.shapes.RECTANGLE, {
      x: 0, y: 0, w: 0.15, h: SLIDE.h,
      fill: { color: COLORS.primary }
    });

    slide.addText("COMPANY PURPOSE", {
      x: MARGIN + 0.2, y: 0.5, w: 3, h: 0.4,
      fontSize: 12, fontFace: FONTS.body, color: COLORS.muted, bold: true
    });

    slide.addText(slideConfig.statement || "", {
      x: MARGIN + 0.2, y: 1.5, w: SLIDE.w - MARGIN * 2 - 0.5, h: 2,
      fontSize: 32, fontFace: FONTS.title, color: COLORS.dark,
      align: "left", valign: "middle"
    });

    addSlideNumber(slide, slideNum, totalSlides);
    addLogo(slide, company.logo);
  },

  problem: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.light };

    slide.addShape(pres.shapes.RECTANGLE, {
      x: 0, y: 0, w: 0.06, h: SLIDE.h,
      fill: { color: COLORS.primary }
    });

    slide.addText(slideConfig.headline || "THE PROBLEM", {
      x: MARGIN, y: 0.35, w: 5, h: 0.6,
      fontSize: 28, fontFace: FONTS.heading, color: COLORS.primary, bold: true
    });

    const points = slideConfig.points || slideConfig.bullets || [];
    const pointsText = points.map((p, i) => ({
      text: p,
      options: { bullet: true, breakLine: i < points.length - 1 }
    }));

    slide.addText(pointsText, {
      x: MARGIN, y: 1.2, w: 5.5, h: 2.8,
      fontSize: 16, fontFace: FONTS.body, color: COLORS.dark,
      paraSpaceAfter: 10
    });

    if (slideConfig.statistic) {
      const statText = typeof slideConfig.statistic === 'object'
        ? `${slideConfig.statistic.value || ''} — ${slideConfig.statistic.label || ''}`
        : String(slideConfig.statistic);
      slide.addShape(pres.shapes.RECTANGLE, {
        x: MARGIN, y: 4.2, w: 5.5, h: 0.8,
        fill: { color: COLORS.primary, transparency: 10 }
      });
      slide.addText(statText, {
        x: MARGIN + 0.2, y: 4.35, w: 5.1, h: 0.5,
        fontSize: 14, fontFace: FONTS.body, color: COLORS.primary, bold: true
      });
    }

    addSlideNumber(slide, slideNum, totalSlides);
    addLogo(slide, company.logo);
  },

  solution: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.white };

    slide.addText(slideConfig.headline || "OUR SOLUTION", {
      x: MARGIN, y: 0.4, w: 5, h: 0.6,
      fontSize: 28, fontFace: FONTS.heading, color: COLORS.primary, bold: true
    });

    slide.addText(slideConfig.valueProposition || slideConfig.valueProp || "", {
      x: MARGIN, y: 1.2, w: 5.5, h: 0.8,
      fontSize: 20, fontFace: FONTS.body, color: COLORS.dark, bold: true
    });

    const benefits = slideConfig.benefits || [];
    benefits.forEach((benefit, i) => {
      const y = 2.2 + (i * 0.9);
      slide.addShape(pres.shapes.OVAL, {
        x: MARGIN, y: y + 0.15, w: 0.2, h: 0.2,
        fill: { color: COLORS.accent }
      });
      slide.addText(benefit, {
        x: MARGIN + 0.4, y: y, w: 5, h: 0.7,
        fontSize: 16, fontFace: FONTS.body, color: COLORS.dark
      });
    });

    addSlideNumber(slide, slideNum, totalSlides);
    addLogo(slide, company.logo);
  },

  whyNow: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.white };

    slide.addText(slideConfig.headline || "WHY NOW?", {
      x: MARGIN, y: 0.4, w: SLIDE.w - MARGIN * 2, h: 0.6,
      fontSize: 28, fontFace: FONTS.heading, color: COLORS.primary, bold: true
    });

    const trends = slideConfig.trends || [];
    const cardW = 2.8;

    trends.forEach((trend, i) => {
      const x = MARGIN + (i * (cardW + 0.2));
      slide.addShape(pres.shapes.RECTANGLE, {
        x: x, y: 1.3, w: cardW, h: 3.5,
        fill: { color: COLORS.light }
      });
      slide.addShape(pres.shapes.RECTANGLE, {
        x: x, y: 1.3, w: cardW, h: 0.08,
        fill: { color: COLORS.accent }
      });
      slide.addText(trend.title || `Trend ${i + 1}`, {
        x: x + 0.15, y: 1.5, w: cardW - 0.3, h: 0.6,
        fontSize: 16, fontFace: FONTS.heading, color: COLORS.primary, bold: true
      });
      slide.addText(trend.description || "", {
        x: x + 0.15, y: 2.2, w: cardW - 0.3, h: 2.4,
        fontSize: 13, fontFace: FONTS.body, color: COLORS.dark
      });
    });

    addSlideNumber(slide, slideNum, totalSlides);
    addLogo(slide, company.logo);
  },

  marketSize: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.white };

    slide.addText(slideConfig.headline || "MARKET OPPORTUNITY", {
      x: MARGIN, y: 0.4, w: SLIDE.w - MARGIN * 2, h: 0.6,
      fontSize: 28, fontFace: FONTS.heading, color: COLORS.primary, bold: true
    });

    const markets = [
      { label: "TAM", value: slideConfig.tam, desc: slideConfig.tamDesc || "Total Addressable Market" },
      { label: "SAM", value: slideConfig.sam, desc: slideConfig.samDesc || "Serviceable Addressable Market" },
      { label: "SOM", value: slideConfig.som, desc: slideConfig.somDesc || "Serviceable Obtainable Market" }
    ];

    markets.forEach((market, i) => {
      const x = MARGIN + (i * 3);
      slide.addText(market.value || "$XXB", {
        x: x, y: 1.3, w: 2.8, h: 1,
        fontSize: 48, fontFace: FONTS.heading, color: COLORS.primary, bold: true, align: "center"
      });
      slide.addText(market.label, {
        x: x, y: 2.3, w: 2.8, h: 0.5,
        fontSize: 20, fontFace: FONTS.heading, color: COLORS.accent, bold: true, align: "center"
      });
      slide.addText(market.desc, {
        x: x, y: 2.8, w: 2.8, h: 0.8,
        fontSize: 12, fontFace: FONTS.body, color: COLORS.muted, align: "center"
      });
    });

    addSlideNumber(slide, slideNum, totalSlides);
    addLogo(slide, company.logo);
  },

  competition: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.white };

    slide.addText(slideConfig.headline || "COMPETITIVE LANDSCAPE", {
      x: MARGIN, y: 0.4, w: SLIDE.w - MARGIN * 2, h: 0.6,
      fontSize: 28, fontFace: FONTS.heading, color: COLORS.primary, bold: true
    });

    // Simple 2x2 matrix
    const matrixX = 0.8, matrixY = 1.3, matrixW = 5.5, matrixH = 3.5;

    slide.addShape(pres.shapes.RECTANGLE, {
      x: matrixX, y: matrixY, w: matrixW, h: matrixH,
      fill: { color: COLORS.light }
    });

    // Axis labels
    slide.addText(slideConfig.xAxisLabel || "Feature X →", {
      x: matrixX, y: matrixY + matrixH + 0.2, w: matrixW, h: 0.3,
      fontSize: 11, fontFace: FONTS.body, color: COLORS.dark, align: "center"
    });

    const competitors = slideConfig.competitors || [];
    competitors.forEach(comp => {
      const cx = matrixX + (comp.x || 0.5) * matrixW;
      const cy = matrixY + (1 - (comp.y || 0.5)) * matrixH;
      slide.addShape(pres.shapes.OVAL, {
        x: cx - 0.2, y: cy - 0.2, w: 0.4, h: 0.4,
        fill: { color: comp.isUs ? COLORS.accent : COLORS.muted }
      });
      slide.addText(comp.name, {
        x: cx - 0.5, y: cy + 0.25, w: 1, h: 0.3,
        fontSize: 9, fontFace: FONTS.body, color: comp.isUs ? COLORS.primary : COLORS.muted,
        align: "center", bold: comp.isUs
      });
    });

    addSlideNumber(slide, slideNum, totalSlides);
    addLogo(slide, company.logo);
  },

  product: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.light };

    slide.addText(slideConfig.headline || "THE PRODUCT", {
      x: MARGIN, y: 0.4, w: SLIDE.w - MARGIN * 2, h: 0.6,
      fontSize: 28, fontFace: FONTS.heading, color: COLORS.primary, bold: true
    });

    slide.addText(slideConfig.description || "", {
      x: MARGIN, y: 1.1, w: SLIDE.w - MARGIN * 2, h: 0.8,
      fontSize: 16, fontFace: FONTS.body, color: COLORS.dark
    });

    const features = slideConfig.features || [];
    features.forEach((feature, i) => {
      const y = 2.2 + (i * 0.8);
      slide.addShape(pres.shapes.OVAL, {
        x: MARGIN, y: y, w: 0.4, h: 0.4,
        fill: { color: COLORS.accent }
      });
      slide.addText(String(i + 1), {
        x: MARGIN, y: y + 0.05, w: 0.4, h: 0.35,
        fontSize: 14, fontFace: FONTS.heading, color: COLORS.white, align: "center", bold: true
      });
      slide.addText(typeof feature === 'object' ? feature.title : feature, {
        x: MARGIN + 0.6, y: y + 0.05, w: SLIDE.w - MARGIN * 2 - 0.8, h: 0.35,
        fontSize: 14, fontFace: FONTS.heading, color: COLORS.dark, bold: true
      });
    });

    addSlideNumber(slide, slideNum, totalSlides);
    addLogo(slide, company.logo);
  },

  businessModel: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.white };

    slide.addText(slideConfig.headline || "BUSINESS MODEL", {
      x: MARGIN, y: 0.4, w: SLIDE.w - MARGIN * 2, h: 0.6,
      fontSize: 28, fontFace: FONTS.heading, color: COLORS.primary, bold: true
    });

    slide.addText(slideConfig.model || "Revenue Model", {
      x: MARGIN, y: 1.1, w: SLIDE.w - MARGIN * 2, h: 0.5,
      fontSize: 20, fontFace: FONTS.body, color: COLORS.dark, bold: true
    });

    const streams = slideConfig.revenueStreams || [];
    const streamW = (SLIDE.w - MARGIN * 2 - 0.4) / Math.min(streams.length || 1, 3);

    streams.forEach((stream, i) => {
      const x = MARGIN + (i * (streamW + 0.2));
      slide.addShape(pres.shapes.RECTANGLE, {
        x: x, y: 1.8, w: streamW, h: 2.2,
        fill: { color: COLORS.light }
      });
      slide.addText(stream.name || `Stream ${i + 1}`, {
        x: x + 0.15, y: 2, w: streamW - 0.3, h: 0.5,
        fontSize: 14, fontFace: FONTS.heading, color: COLORS.primary, bold: true
      });
      slide.addText(stream.description || "", {
        x: x + 0.15, y: 2.5, w: streamW - 0.3, h: 1.3,
        fontSize: 12, fontFace: FONTS.body, color: COLORS.dark
      });
    });

    addSlideNumber(slide, slideNum, totalSlides);
    addLogo(slide, company.logo);
  },

  traction: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.white };

    slide.addText(slideConfig.headline || "TRACTION", {
      x: MARGIN, y: 0.4, w: SLIDE.w - MARGIN * 2, h: 0.6,
      fontSize: 28, fontFace: FONTS.heading, color: COLORS.primary, bold: true
    });

    const metrics = slideConfig.metrics || [];
    const metricW = 2.8;

    metrics.slice(0, 3).forEach((metric, i) => {
      const x = MARGIN + (i * (metricW + 0.2));
      slide.addText(metric.value || "XX", {
        x: x, y: 1.2, w: metricW, h: 1,
        fontSize: 48, fontFace: FONTS.heading, color: COLORS.primary, bold: true, align: "center"
      });
      slide.addText(metric.label || "Metric", {
        x: x, y: 2.2, w: metricW, h: 0.4,
        fontSize: 14, fontFace: FONTS.body, color: COLORS.muted, align: "center"
      });
    });

    if (slideConfig.milestones) {
      slide.addText("Key Milestones", {
        x: MARGIN, y: 3, w: SLIDE.w - MARGIN * 2, h: 0.4,
        fontSize: 16, fontFace: FONTS.heading, color: COLORS.dark, bold: true
      });
      const msText = (slideConfig.milestones || []).map((m, i) => ({
        text: m,
        options: { bullet: true, breakLine: i < slideConfig.milestones.length - 1 }
      }));
      slide.addText(msText, {
        x: MARGIN, y: 3.5, w: SLIDE.w - MARGIN * 2, h: 1.5,
        fontSize: 14, fontFace: FONTS.body, color: COLORS.dark, paraSpaceAfter: 6
      });
    }

    addSlideNumber(slide, slideNum, totalSlides);
    addLogo(slide, company.logo);
  },

  team: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.light };

    slide.addText(slideConfig.headline || "THE TEAM", {
      x: MARGIN, y: 0.4, w: SLIDE.w - MARGIN * 2, h: 0.6,
      fontSize: 28, fontFace: FONTS.heading, color: COLORS.primary, bold: true
    });

    const members = slideConfig.members || [];
    const memberW = Math.min(2.8, (SLIDE.w - MARGIN * 2 - 0.4) / (members.length || 1));

    members.slice(0, 4).forEach((member, i) => {
      const x = MARGIN + (i * (memberW + 0.2));

      // Photo placeholder circle
      slide.addShape(pres.shapes.OVAL, {
        x: x + (memberW - 1.2) / 2, y: 1.2, w: 1.2, h: 1.2,
        fill: { color: COLORS.secondary }
      });
      const initials = (member.name || "").split(" ").map(n => n[0]).join("").slice(0, 2);
      slide.addText(initials, {
        x: x + (memberW - 1.2) / 2, y: 1.55, w: 1.2, h: 0.5,
        fontSize: 24, fontFace: FONTS.heading, color: COLORS.white, align: "center", bold: true
      });

      slide.addText(member.name || "Name", {
        x: x, y: 2.5, w: memberW, h: 0.4,
        fontSize: 14, fontFace: FONTS.heading, color: COLORS.dark, bold: true, align: "center"
      });
      slide.addText(member.title || "Title", {
        x: x, y: 2.9, w: memberW, h: 0.35,
        fontSize: 12, fontFace: FONTS.body, color: COLORS.accent, align: "center"
      });
      slide.addText(member.background || member.credential || "", {
        x: x, y: 3.3, w: memberW, h: 1.2,
        fontSize: 10, fontFace: FONTS.body, color: COLORS.muted, align: "center"
      });
    });

    addSlideNumber(slide, slideNum, totalSlides);
    addLogo(slide, company.logo);
  },

  ask: (slideConfig, slideNum, totalSlides) => {
    const slide = pres.addSlide();
    slide.background = { color: COLORS.primary };

    slide.addText(slideConfig.headline || "THE ASK", {
      x: MARGIN, y: 0.4, w: SLIDE.w - MARGIN * 2, h: 0.6,
      fontSize: 28, fontFace: FONTS.heading, color: COLORS.white, bold: true
    });

    slide.addText(slideConfig.amount || "$X Million", {
      x: MARGIN, y: 1.2, w: 5, h: 0.8,
      fontSize: 44, fontFace: FONTS.title, color: COLORS.accent, bold: true
    });
    slide.addText(slideConfig.round || "Series A", {
      x: MARGIN, y: 2, w: 5, h: 0.4,
      fontSize: 20, fontFace: FONTS.body, color: COLORS.light
    });

    slide.addText("Use of Funds", {
      x: MARGIN, y: 2.7, w: 5, h: 0.4,
      fontSize: 16, fontFace: FONTS.heading, color: COLORS.light, bold: true
    });

    const uses = slideConfig.useOfFunds || [];
    const usesText = uses.map((u, i) => ({
      text: `${u.percent || "XX"}% - ${u.category || "Category"}`,
      options: { bullet: true, breakLine: i < uses.length - 1 }
    }));
    slide.addText(usesText, {
      x: MARGIN, y: 3.15, w: 5, h: 1.8,
      fontSize: 14, fontFace: FONTS.body, color: COLORS.white, paraSpaceAfter: 6
    });

    // Milestones on right
    slide.addText("Milestones", {
      x: 5.5, y: 1.2, w: 4, h: 0.4,
      fontSize: 16, fontFace: FONTS.heading, color: COLORS.light, bold: true
    });
    const milestones = slideConfig.milestones || [];
    const msText = milestones.map((m, i) => ({
      text: m,
      options: { bullet: true, breakLine: i < milestones.length - 1 }
    }));
    slide.addText(msText, {
      x: 5.5, y: 1.65, w: 4, h: 2.5,
      fontSize: 14, fontFace: FONTS.body, color: COLORS.white, paraSpaceAfter: 6
    });

    // Contact
    slide.addShape(pres.shapes.RECTANGLE, {
      x: MARGIN, y: 4.8, w: SLIDE.w - MARGIN * 2, h: 0.5,
      fill: { color: COLORS.accent }
    });
    slide.addText(slideConfig.contact || `${company.name} | email@company.com`, {
      x: MARGIN, y: 4.85, w: SLIDE.w - MARGIN * 2, h: 0.4,
      fontSize: 14, fontFace: FONTS.body, color: COLORS.dark, align: "center", bold: true
    });

    addLogo(slide, company.logo);
  }
};

// =============================================================================
// Generate Slides
// =============================================================================

console.log(`\nGenerating deck: ${company.name}`);
console.log(`Mode: ${imageOnlyMode ? "Image-Only" : "Image-First (with fallback)"}`);
console.log(`Slides: ${slides.length}\n`);

const totalSlides = slides.length;
let imageSlides = 0;
let fallbackSlides = 0;

slides.forEach((slideConfig, index) => {
  const slideNum = index + 1;
  const slideType = slideConfig.type;

  // Try image-first approach
  const imageGenerated = generateImageSlide(slideConfig, slideNum, totalSlides);

  if (imageGenerated) {
    imageSlides++;
    console.log(`  ${slideNum}. ${slideType.padEnd(15)} [IMAGE]`);
  } else if (imageOnlyMode) {
    // In image-only mode, create error placeholder slide
    const slide = pres.addSlide();
    slide.background = { color: "FF0000" };
    slide.addText(`Missing image for: ${slideType}`, {
      x: MARGIN, y: SLIDE.h / 2 - 0.3, w: SLIDE.w - MARGIN * 2, h: 0.6,
      fontSize: 24, color: COLORS.white, align: "center", fontFace: FONTS.heading
    });
    slide.addText(`Expected: assets/${slideType}.png`, {
      x: MARGIN, y: SLIDE.h / 2 + 0.3, w: SLIDE.w - MARGIN * 2, h: 0.4,
      fontSize: 14, color: COLORS.white, align: "center", fontFace: FONTS.body
    });
    fallbackSlides++;
    console.log(`  ${slideNum}. ${slideType.padEnd(15)} [MISSING]`);
  } else {
    // Use fallback programmatic generator
    const generator = fallbackGenerators[slideType];
    if (generator) {
      generator(slideConfig, slideNum, totalSlides);
      fallbackSlides++;
      console.log(`  ${slideNum}. ${slideType.padEnd(15)} [FALLBACK]`);
    } else {
      console.warn(`  ${slideNum}. ${slideType.padEnd(15)} [UNKNOWN TYPE]`);
    }
  }
});

// =============================================================================
// Save Presentation
// =============================================================================

console.log("\n----------------------------------------");
console.log(`Image slides: ${imageSlides}`);
console.log(`Fallback slides: ${fallbackSlides}`);

pres.writeFile({ fileName: outputPath })
  .then(() => {
    console.log(`\n✓ Presentation saved: ${outputPath}`);
    console.log(`  ${totalSlides} slides generated`);
  })
  .catch(err => {
    console.error("\nError saving presentation:", err);
    process.exit(1);
  });
